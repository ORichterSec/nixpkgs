diff --git a/addon/linux_esdm_es/esdm_definitions.h b/addon/linux_esdm_es/esdm_definitions.h
index 80c067f9eb9..f427c3b5e45 100644
--- a/addon/linux_esdm_es/esdm_definitions.h
+++ b/addon/linux_esdm_es/esdm_definitions.h
@@ -63,8 +63,9 @@
  *
  * This value is allowed to be changed.
  */
+#ifndef ESDM_DRNG_MAX_WITHOUT_RESEED
 #define ESDM_DRNG_MAX_WITHOUT_RESEED	(1<<30)
-
+#endif
 /*
  * Min required seed entropy is 128 bits covering the minimum entropy
  * requirement of SP800-131A and the German BSI's TR02102.
diff --git a/common/meson.build b/common/meson.build
index fc864cdf32a..66096ac50b3 100644
--- a/common/meson.build
+++ b/common/meson.build
@@ -34,6 +34,14 @@ conf_data.set('ESDM_HASH_SHA512', get_option('hash_sha512').enabled())
 conf_data.set('ESDM_HASH_SHA3_512', get_option('hash_sha3_512').enabled())
 conf_data.set('ESDM_GNUTLS', get_option('gnutls').enabled())
 
+if (get_option('maxrandombits') >= 0)
+	conf_data.set('EDSM_DRNG_MAX_BITS_WITHOUT_RESEED_VALUE', get_option('maxrandombits'))
+endif
+
+if (get_option('esdm_drop_bits') >= 0)
+	conf_data.set('ESDM_DRNG_DROP_BITS_VAL', get_option('esdm_drop_bits'))
+endif
+
 # This option currently is not configurable!
 conf_data.set('CONFIG_ESDM_USE_PTHREAD', true)
 conf_data.set('THREADING_MAX_THREADS', get_option('threading_max_threads'))
diff --git a/esdm/esdm_config.c b/esdm/esdm_config.c
index 11d9f3bd58a..361a4aa382b 100644
--- a/esdm/esdm_config.c
+++ b/esdm/esdm_config.c
@@ -38,6 +38,7 @@ struct esdm_config {
 	uint32_t esdm_es_krng_entropy_rate_bits;
 	uint32_t esdm_es_sched_entropy_rate_bits;
 	uint32_t esdm_es_hwrand_entropy_rate_bits;
+	uint32_t esdm_drgn_max_requests_bits;
 	uint32_t esdm_drng_max_wo_reseed;
 	uint32_t esdm_max_nodes;
 	enum esdm_config_force_fips force_fips;
@@ -82,6 +83,11 @@ static struct esdm_config esdm_config = {
 	 */
 	.esdm_es_hwrand_entropy_rate_bits = ESDM_HWRAND_ENTROPY_RATE,
 
+	/*
+	 * See documentation of ESDM_HWRAND_ENTROPY_RATE
+	 */
+	.esdm_drgn_max_requests_bits = EDSM_DRNG_MAX_BITS_WITHOUT_RESEED,
+
 	/*
 	 * See documentation of ESDM_DRNG_MAX_WITHOUT_RESEED.
 	 */
@@ -205,6 +211,13 @@ void esdm_config_es_hwrand_entropy_rate_set(uint32_t ent)
 	esdm_es_add_entropy();
 }
 
+DSO_PUBLIC
+uint32_t esdm_config_drng_max_requests_bits(void)
+{
+	return esdm_config.esdm_drgn_max_requests_bits;
+}
+
+
 DSO_PUBLIC
 uint32_t esdm_config_drng_max_wo_reseed(void)
 {
diff --git a/esdm/esdm_config.h b/esdm/esdm_config.h
index 286788c1697..38ec106c1de 100644
--- a/esdm/esdm_config.h
+++ b/esdm/esdm_config.h
@@ -135,6 +135,15 @@ void esdm_config_es_hwrand_entropy_rate_set(uint32_t ent);
  */
 uint32_t esdm_config_es_hwrand_entropy_rate(void);
 
+/**
+ * @brief DRNG Manager configuration: get maximum value of requested bits
+ * without reseed
+ *
+ * @return Maximum allowed number of requested bits without reseed.
+ */
+
+uint32_t esdm_config_drng_max_requests_bits(void);
+
 /**
  * @brief DRNG Manager configuration: get maximum value without successful
  *	  reseed
diff --git a/esdm/esdm_definitions.h b/esdm/esdm_definitions.h
index 259667a6540..bf0d995931f 100644
--- a/esdm/esdm_definitions.h
+++ b/esdm/esdm_definitions.h
@@ -56,6 +56,21 @@
  */
 #define ESDM_DRNG_RESEED_THRESH		(1<<20)
 
+/*
+ * AIS 20/31 DRG4.10 requires at most 2^17 maybe generated until requiring reseed.
+ */
+#ifdef EDSM_DRNG_MAX_BITS_WITHOUT_RESEED_VALUE
+#define EDSM_DRNG_MAX_BITS_WITHOUT_RESEED (1<<EDSM_DRNG_MAX_BITS_WITHOUT_RESEED_VALUE)
+#else
+#define EDSM_DRNG_MAX_BITS_WITHOUT_RESEED (1<<17)
+#endif
+
+/*
+ * Specified amount of bits that are to be dropped before they are used for seeding the dngr
+ */
+#ifndef ESDM_DRNG_DROP_BITS_VAL
+#define ESDM_DRNG_DROP_BITS_VAL 5000
+#endif
 /*
  * Maximum DRNG generation operations without reseed having full entropy
  * This value defines the absolute maximum value of DRNG generation operations
diff --git a/esdm/esdm_drng_mgr.c b/esdm/esdm_drng_mgr.c
index 58132eb63da..7a3a7fd4384 100644
--- a/esdm/esdm_drng_mgr.c
+++ b/esdm/esdm_drng_mgr.c
@@ -129,6 +129,7 @@ void esdm_drng_reset(struct esdm_drng *drng)
 	/* Ensure reseed during next call */
 	atomic_set(&drng->requests, 1);
 	atomic_set(&drng->requests_since_fully_seeded, 0);
+	atomic_set(&drng->requests_bits, 0);
 	drng->last_seeded = time(NULL);
 	drng->fully_seeded = false;
 	/* Do not set force, as this flag is used for the emergency reseeding */
@@ -362,11 +363,16 @@ void esdm_drng_inject(struct esdm_drng *drng,
 		       "%s DRNG stats since last seeding: %lu secs; generate calls: %d\n",
 		       drng_type, esdm_time_after_now(drng->last_seeded), gc);
 
-		/* Count the numbers of generate ops since last fully seeded */
-		if (fully_seeded)
+		/* Count the numbers of generate ops and bits since last fully seeded */
+		if (fully_seeded){
 			atomic_set(&drng->requests_since_fully_seeded, 0);
-		else
+			logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "reset requested_bits (%zd) --> 0 on node (%zd)\n", drng->requests_bits, esdm_curr_node());
+			atomic_set(&drng->requests_bits, 0);
+		}
+		else{
+			logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "drng->fully_seeded == false\n");
 			atomic_add(&drng->requests_since_fully_seeded, gc);
+		}
 
 		drng->last_seeded = time(NULL);
 		atomic_set(&drng->requests, ESDM_DRNG_RESEED_THRESH);
@@ -388,6 +394,8 @@ void esdm_drng_inject(struct esdm_drng *drng,
 static uint32_t esdm_drng_seed_es_nolock(struct esdm_drng *drng, bool init_ops,
 					 const char *drng_type)
 {
+	//todo drop first #ESDM_DRNG_DROP_BITS_VAL bits of incoming entropy before using it for seeding the drng
+
 	struct entropy_buf seedbuf __aligned(ESDM_KCAPI_ALIGN),
 			   collected_seedbuf;
 	uint32_t collected_entropy = 0;
@@ -403,6 +411,46 @@ static uint32_t esdm_drng_seed_es_nolock(struct esdm_drng *drng, bool init_ops,
 	 */
 	memset(&seedbuf, 0, sizeof(seedbuf));
 
+	logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "hit function esdm_drng_seed_es_nolock | drng->dropped_bits_at_start == %zd <------------\n", drng->dropped_bits_at_start);
+	//drop the bits first if this is the first time seeding the drng
+	if(!drng->dropped_bits_at_start) {
+		struct entropy_buf dropbuf;
+		uint32_t dropped_entropy = atomic_read_u32(&drng->dropped_bits);
+		logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "Dropped entropy set to:%zd | ESDM_DRNG_DROP_BITS_VAL: %zd \n", dropped_entropy, ESDM_DRNG_DROP_BITS_VAL);
+		while(dropped_entropy < ESDM_DRNG_DROP_BITS_VAL){
+			//fetch the entropy into our dropbuf
+			// esdm_fill_seed_buffer(&dropbuf, ESDM_DRNG_DROP_BITS_VAL, true);
+			uint32_t todo = min_uint32(ESDM_DRNG_DROP_BITS_VAL - dropped_entropy, esdm_security_strength());
+			logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "avail_entropy:(%zd), security_streng:(%zd) | todo: (%zd)\n", esdm_avail_entropy(), esdm_security_strength(), todo);
+			//todo: this does retrieve more bits than we would want right now
+			esdm_fill_seed_buffer(&dropbuf, todo, true);
+			uint32_t current_ent;
+			current_ent = esdm_entropy_rate_eb(&dropbuf);
+			dropped_entropy += current_ent;
+			logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "dropping entropy before using it to seed --> dropped: (%zd)/(%zd)bits | current_entropy:(%zd) currently on core: (%zd)\n", dropped_entropy, ESDM_DRNG_DROP_BITS_VAL, current_ent, esdm_curr_node());
+		
+			//todo maybe return her with 0 if the required ammount is not dropped yet
+			//and we have no further entropy available
+			if(current_ent == 0){
+				logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "no more entropy returning: %zd\n",current_ent);
+				atomic_set(&drng->dropped_bits, dropped_entropy);
+				return;
+			}
+
+			if(esdm_avail_entropy() < esdm_security_strength()){
+				logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "error while dropping bits: (avail_entropy)%zd < (security_strength)%zd\n", esdm_avail_entropy(), esdm_security_strength());
+			}
+		}
+		if(dropped_entropy < ESDM_DRNG_DROP_BITS_VAL){
+			logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "we still have not dropped enough entropy somehow\n");
+		}else if(dropped_entropy > ESDM_DRNG_DROP_BITS_VAL){
+			logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "somehow we dropped more entropy then we needed\n");
+		}else if(dropped_entropy == ESDM_DRNG_DROP_BITS_VAL){
+			logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "dropping worked\n");
+		}
+		drng->dropped_bits_at_start = true;
+	}
+
 	do {
 		/* Count the number of ES which delivered entropy */
 		num_es_delivered = 0;
@@ -603,8 +651,21 @@ out:
 	esdm_drng_put_instances();
 }
 
+void esdm_drng_add_requests_bits(struct esdm_drng *drng, int val)
+{
+	logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "current node: (%zd) | adding requests bits current: %zd | add val: %zd | cast of val: %zd\n",
+											esdm_curr_node(),drng->requests_bits, val, (uint32_t) val);
+	atomic_add(&drng->requests_bits, val);
+}
+
 static bool esdm_drng_must_reseed(struct esdm_drng *drng)
 {
+	uint32_t requested_bits = atomic_read_u32(&drng->requests_bits);
+	if(requested_bits >= esdm_config_drng_max_requests_bits()){
+		logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "must reseed because limit for requested bits (%zd/%zd) are reached\n", requested_bits, esdm_config_drng_max_requests_bits());
+		// atomic_set(&drng->requests_bits, esdm_config_drng_max_requests_bits());
+		return true;
+	}
 	return (atomic_dec_and_test(&drng->requests) ||
 		drng->force_reseed ||
 		esdm_time_after_now(drng->last_seeded +
@@ -638,19 +699,20 @@ static ssize_t esdm_drng_get(struct esdm_drng *drng, uint8_t *outbuf,
 	outbuflen = min_size(outbuflen, SSIZE_MAX);
 
 	if (atomic_read_u32(&drng->requests_since_fully_seeded) >
-	    esdm_config_drng_max_wo_reseed())
+	    esdm_config_drng_max_wo_reseed() || atomic_read_u32(&drng->requests_bits) == esdm_config_drng_max_requests_bits())
 		esdm_unset_fully_seeded(drng);
 
 	while (outbuflen) {
 		uint32_t todo = min_uint32((uint32_t)outbuflen,
 					   ESDM_DRNG_MAX_REQSIZE);
 		ssize_t ret;
-
 		/* In normal operation, check whether to reseed */
 		if (!pr && esdm_drng_must_reseed(drng)) {
 			if (!esdm_pool_trylock()) {
+				logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "lock failed set force_reseed\n");
 				drng->force_reseed = true;
 			} else {
+				logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "lock successfull reseed drng\n");
 				esdm_drng_seed(drng);
 				esdm_pool_unlock();
 			}
@@ -698,6 +760,16 @@ static ssize_t esdm_drng_get(struct esdm_drng *drng, uint8_t *outbuf,
 			       ret);
 			return -EFAULT;
 		}
+		
+		esdm_drng_add_requests_bits(drng, ret<<3);
+		logger(LOGGER_DEBUG2, LOGGER_C_DRNG,
+					"current node: (%zd) | requests_bits = (%zd) out of max_requests_bits = (%zd) | todo: (%zd) | ret: (%zd) <--------\n",
+					esdm_curr_node(),
+					atomic_read_u32(&drng->requests_bits),
+					EDSM_DRNG_MAX_BITS_WITHOUT_RESEED,
+					todo,
+					ret
+					);
 		processed += ret;
 		outbuflen -= (size_t)ret;
 
diff --git a/esdm/esdm_drng_mgr.h b/esdm/esdm_drng_mgr.h
index 7b3c19c5d9f..5db986bcfe5 100644
--- a/esdm/esdm_drng_mgr.h
+++ b/esdm/esdm_drng_mgr.h
@@ -42,12 +42,15 @@ struct esdm_drng {
 	const struct esdm_drng_cb *drng_cb;	/* DRNG callbacks */
 	const struct esdm_hash_cb *hash_cb;	/* Hash callbacks */
 	atomic_t requests;			/* Number of DRNG requests */
+	atomic_t requests_bits; /*Number of requested bit since last reseed*/
+	atomic_t dropped_bits; /*Number of dropped bits*/
 	atomic_t requests_since_fully_seeded;	/* Number DRNG requests since
 						 * last fully seeded
 						 */
 	time_t last_seeded;			/* Last time it was seeded */
 	bool fully_seeded;			/* Is DRNG fully seeded? */
 	bool force_reseed;			/* Force a reseed */
+	bool dropped_bits_at_start;
 
 	mutex_t hash_lock;			/* Lock hash_cb replacement */
 	/* Lock write operations on DRNG state, DRNG replacement of drng_cb */
@@ -59,10 +62,13 @@ struct esdm_drng {
 	.drng_cb			= d_cb, \
 	.hash_cb			= h_cb, \
 	.requests			= ATOMIC_INIT(ESDM_DRNG_RESEED_THRESH),\
+	.requests_bits		= ATOMIC_INIT(0), \
+	.dropped_bits		= ATOMIC_INIT(0), \
 	.requests_since_fully_seeded	= ATOMIC_INIT(0), \
 	.last_seeded			= 0, \
 	.fully_seeded			= false, \
 	.force_reseed			= true, \
+	.dropped_bits_at_start  = false, \
 	.hash_lock			= MUTEX_UNLOCKED
 
 struct esdm_drng *esdm_drng_init_instance(void);
@@ -81,6 +87,7 @@ void esdm_drng_inject(struct esdm_drng *drng,
 		      bool fully_seeded, const char *drng_type);
 void esdm_drng_seed_work(void);
 void esdm_force_fully_seeded(void);
+void esdm_drng_add_requests_bits(struct esdm_drng *drng, int val);
 void esdm_force_fully_seeded_all_drbgs(void);
 
 static inline uint32_t esdm_compress_osr(void)
diff --git a/esdm/esdm_es_mgr.c b/esdm/esdm_es_mgr.c
index 28c7349cb33..6b66be0a8b8 100644
--- a/esdm/esdm_es_mgr.c
+++ b/esdm/esdm_es_mgr.c
@@ -737,7 +737,7 @@ void esdm_fill_seed_buffer(struct entropy_buf *eb, uint32_t requested_bits,
 	    state->esdm_fully_seeded && (esdm_avail_entropy() < req_ent)) {
 		for_each_esdm_es(i)
 			eb->entropy_es[i].e_bits = 0;
-
+		logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "reset all the entropy bits in our entropy buffer\n");
 		goto wakeup;
 	}
 
@@ -745,6 +745,7 @@ void esdm_fill_seed_buffer(struct entropy_buf *eb, uint32_t requested_bits,
 	for_each_esdm_es(i) {
 		esdm_es[i]->get_ent(&eb->entropy_es[i], requested_bits,
 				    state->esdm_fully_seeded);
+		logger(LOGGER_DEBUG2, LOGGER_C_DRNG, "in esdm_fill_seed_buffer: set %zd to %zd\n", i, eb->entropy_es[i].e_bits);
 	}
 
 wakeup:
diff --git a/meson_options.txt b/meson_options.txt
index db4a2b9cf03..d46be78f294 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -295,6 +295,12 @@ option('hash_sha3_512', type: 'feature', value: 'disabled',
 option('gnutls', type: 'feature', value: 'disabled',
        description: 'Enable GnuTLS backend to provide cryptographic primitives')
 
+option('maxrandombits', type: 'integer', value: 17,
+       description:  'todo description - change number')
+
+option('esdm_drop_bits', type: 'integer', value: 4000,
+       description:  'todo description - change number')
+
 ################################################################################
 # Linux Interface Configuration
 ################################################################################
